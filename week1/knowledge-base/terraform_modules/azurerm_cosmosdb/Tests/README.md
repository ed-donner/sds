# Infra Team Test

This template is used for testing only

<!-- BEGIN_TF_DOCS -->
## Requirements

| Name | Version |
|------|---------|
| <a name="requirement_azurerm"></a> [azurerm](#requirement\_azurerm) | 4.20.0 |

## Providers

No providers.

## Modules

| Name | Source | Version |
|------|--------|---------|
| <a name="module_cosmosdb"></a> [cosmosdb](#module\_cosmosdb) | git::ssh://git@ssh.dev.azure.com/v3/Axpo-AXSO/TIM-INFRA-MODULES/azurerm_cosmosdb | ~{gitRef}~ |

## Resources

No resources.

## Inputs

| Name | Description | Type | Default | Required |
|------|-------------|------|---------|:--------:|
| <a name="input_cosmosdb_accounts"></a> [cosmosdb\_accounts](#input\_cosmosdb\_accounts) | A list of configurations for Cosmos DB accounts, supporting various API types like NoSQL, MongoDB, Cassandra, Gremlin, Table, and PostgreSQL.<br/><br/>- **name**: The name of the Cosmos DB account, used to uniquely identify the account.<br/>- **cosmosdb\_type**: Specifies the type of Cosmos DB account, such as 'nosql', 'mongo', 'cassandra', 'gremlin'or 'table'<br/>- **free\_tier\_enabled**: Enables or disables free-tier options for the account. When enabled, the account has certain cost savings. Max 1 free-tier account per subscription.<br/>- **analytical\_storage\_enabled**: Defines whether the account has analytical storage capabilities, useful for advanced data querying.<br/>- **burst\_capacity\_enabled**: Allows the account to automatically handle traffic spikes without manually scaling throughput.<br/>- **mongo\_server\_version**: Specifies the MongoDB version if the account uses the MongoDB API. Optional and applicable only for MongoDB.<br/>- **consistency\_policy**: Configures the account's consistency model such as BoundedStaleness, Eventual, Session, Strong  or ConsistentPrefix . The BoundedStaleness policy has a mandatory `consistency_level`, `max_interval_in_seconds`, and `max_staleness_prefix`.<br/>- **geo\_location**: A list of objects defining regional settings, such as the `location` (Azure region), `failover_priority` (failover order), and `zone_redundant` (availability zone distribution).<br/>- **capabilities**: A list of enabled capabilities, such as advanced features like multi-master support or Cassandra API-specific capabilities.<br/>- **analytical\_storage**: Configures the type of analytical storage for fast querying, with the option to specify the `schema_type`.<br/>- **capacity**: Defines the total throughput capacity for the account, including the read/write throughput limit. This is very helpful for managing costs, as it allows you to scale the throughput according to actual usage, preventing over-provisioning.<br/>- **backup**: Backup configurations for the account, such as the `name` of the backup policy, `type` (Continuous or Periodic), `interval_in_minutes`, `retention_in_hours`, and `storage_redundancy` options.<br/>  You can only configure interval\_in\_minutes, retention\_in\_hours and storage\_redundancy when the type field is set to Periodic.<br/>- **cors\_rule**: Specifies Cross-Origin Resource Sharing (CORS) rules, including allowed headers, methods, origins, and optional `max_age_in_seconds` for caching purposes. | <pre>list(object({<br/>    name                       = string<br/>    cosmosdb_type              = string # Add cosmosdb_type here<br/>    free_tier_enabled          = bool<br/>    analytical_storage_enabled = bool<br/>    burst_capacity_enabled     = bool<br/>    mongo_server_version       = optional(string)<br/>    consistency_policy = list(object({<br/>      name                    = string<br/>      consistency_level       = optional(string)<br/>      max_interval_in_seconds = optional(number)<br/>      max_staleness_prefix    = optional(number)<br/>    }))<br/>    geo_location = list(object({<br/>      location          = string<br/>      failover_priority = number<br/>      zone_redundant    = bool<br/>    }))<br/>    capabilities = list(object({<br/>      name = string<br/>    }))<br/>    analytical_storage = list(object({<br/>      schema_type = string<br/>    }))<br/>    capacity = list(object({<br/>      total_throughput_limit = number<br/>    }))<br/>    backup = list(object({<br/>      name                = string<br/>      type                = string<br/>      tier                = optional(string)<br/>      interval_in_minutes = optional(number)<br/>      retention_in_hours  = optional(number)<br/>      storage_redundancy  = optional(string)<br/>    }))<br/>    cors_rule = list(object({<br/>      name               = string<br/>      allowed_headers    = list(string)<br/>      allowed_methods    = list(string)<br/>      allowed_origins    = list(string)<br/>      exposed_headers    = list(string)<br/>      max_age_in_seconds = optional(number)<br/>    }))<br/>  }))</pre> | `null` | no |
| <a name="input_cosmosdb_postgres"></a> [cosmosdb\_postgres](#input\_cosmosdb\_postgres) | Configuration for Cosmos DB PostgreSQL clusters.<br/><br/>- **name**: The name of the PostgreSQL cluster. This is a unique identifier for the cluster within the resource group.<br/>- **sql\_version**: The major PostgreSQL version on the Azure Cosmos DB for PostgreSQL cluster. Possible values are 11, 12, 13, 14, 15 and 16.<br/>- **node\_count**: (Required) The worker node count of the Azure Cosmos DB for PostgreSQL Cluster. Possible value is between 0 and 20 except 1.<br/>- **node\_vcores**: (Optional) The vCores count on each worker node. Possible values are 1, 2, 4, 8, 16, 32, 64, 96 and 104.<br/>- **citus\_version**: (Optional) The citus extension version on the Azure Cosmos DB for PostgreSQL Cluster. Possible values are 8.3, 9.0, 9.1, 9.2, 9.3, 9.4, 9.5, 10.0, 10.1, 10.2, 11.0, 11.1, 11.2, 11.3 and 12.1.<br/>- **coordinator\_server\_edition**: (Optional) The edition of the coordinator server. Possible values are BurstableGeneralPurpose, BurstableMemoryOptimized, GeneralPurpose and MemoryOptimized. Defaults to GeneralPurpose.<br/>- **coordinator\_storage\_quota\_in\_mb**: (Optional) The storage quota for the coordinator node, specified in megabytes.<br/>- **coordinator\_vcore\_count**: (Optional) The coordinator vCore count for the Azure Cosmos DB for PostgreSQL Cluster. Possible values are 1, 2, 4, 8, 16, 32, 64 and 96.<br/>- **node\_server\_edition**: (Optional) The edition of the node server. Possible values are BurstableGeneralPurpose, BurstableMemoryOptimized, GeneralPurpose and MemoryOptimized. Defaults to MemoryOptimized<br/>- **node\_storage\_quota\_in\_mb**: (Optional) The storage quota in MB on each worker node. Possible values are 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608 and 16777216.<br/>- **ha\_enabled**: (Optional) Is high availability enabled for the Azure Cosmos DB for PostgreSQL cluster? Defaults to true.<br/>- **maintenance\_window**: (Optional) Specifies the maintenance window for the cluster. Includes:<br/>  - **day\_of\_week**: Day of the week to perform maintenance (0 for Sunday, 6 for Saturday).<br/>  - **start\_hour**: Hour at which maintenance should begin (in 24-hour format).<br/>  - **start\_minute**: Minute of the hour to begin maintenance. | <pre>list(object({<br/>    name                            = string<br/>    sql_version                     = optional(string)<br/>    node_count                      = number<br/>    node_vcores                     = optional(number)<br/>    citus_version                   = optional(string)<br/>    coordinator_server_edition      = optional(string, "GeneralPurpose")<br/>    coordinator_storage_quota_in_mb = optional(number)<br/>    coordinator_vcore_count         = optional(number)<br/>    node_server_edition             = optional(string, "MemoryOptimized")<br/>    node_storage_quota_in_mb        = optional(number)<br/>    ha_enabled                      = optional(bool, true)<br/>    maintenance_window = optional(object({<br/>      day_of_week  = optional(number)<br/>      start_hour   = optional(number)<br/>      start_minute = optional(number)<br/>    }))<br/>  }))</pre> | `null` | no |
| <a name="input_default_identity_type"></a> [default\_identity\_type](#input\_default\_identity\_type) | The default identity for accessing Key Vault. Possible values are FirstPartyIdentity, SystemAssignedIdentity or UserAssignedIdentity. Defaults to UserAssignedIdentity | `string` | `"UserAssignedIdentity"` | no |
| <a name="input_environment"></a> [environment](#input\_environment) | The short name for the environment. e.g. 'dev', 'qa', 'uat', 'prod' | `string` | `"dev"` | no |
| <a name="input_identity_type"></a> [identity\_type](#input\_identity\_type) | (Required) Specifies the type of Managed Service Identity that should be configured on this App Configuration. Possible values are SystemAssigned, UserAssigned, SystemAssigned, UserAssigned (to enable both). | `string` | `"UserAssigned"` | no |
| <a name="input_key_vault_name"></a> [key\_vault\_name](#input\_key\_vault\_name) | The name of the key vault where the keys are stored | `string` | n/a | yes |
| <a name="input_location"></a> [location](#input\_location) | The default location where the Static App will be created | `string` | n/a | yes |
| <a name="input_pe_subnet_name"></a> [pe\_subnet\_name](#input\_pe\_subnet\_name) | The name of the subnet where the private endpoint will be created | `string` | n/a | yes |
| <a name="input_project_name"></a> [project\_name](#input\_project\_name) | The short name of the project e.g. 'mds' | `string` | n/a | yes |
| <a name="input_resource_group_name"></a> [resource\_group\_name](#input\_resource\_group\_name) | The name of the resource group where your resources should reside | `string` | n/a | yes |
| <a name="input_subscription"></a> [subscription](#input\_subscription) | The short name of the subscription type e.g.  'p' or 'np' | `string` | n/a | yes |
| <a name="input_umids_names"></a> [umids\_names](#input\_umids\_names) | (Optional) The list of User Assigned Managed Identity names to assign to the App Configuration. Changing this forces a new resource to be created. | `list(string)` | `[]` | no |
| <a name="input_virtual_network_name"></a> [virtual\_network\_name](#input\_virtual\_network\_name) | The name of the vnet where the private endpoint will be created | `string` | n/a | yes |
| <a name="input_virtual_network_resource_group_name"></a> [virtual\_network\_resource\_group\_name](#input\_virtual\_network\_resource\_group\_name) | The name of the resource group where the vnet is located | `string` | n/a | yes |

## Outputs

No outputs.
<!-- END_TF_DOCS -->